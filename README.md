# Finance_Accounting

Проект **Finance_Accounting** разработан в рамках второго домашнего задания по курсу «Конструирование программного обеспечения» (КПО). Цель проекта — продемонстрировать применение **паттернов проектирования GoF**, принципов **SOLID** и идей **GRASP** на практике, создавая полноценный модуль «Учет финансов».

# Модуль «Учет финансов»

## 1. Общая идея решения

Данный проект реализует модуль «Учет финансов», который позволяет:

* Создавать, редактировать и удалять **банковские счета** (`BankAccount`).
* Создавать, редактировать и удалять **категории** доходов/расходов (`Category`).
* Создавать, редактировать и удалять **операции** (доходы/расходы) (`Operation`).
* Отслеживать баланс счетов автоматически при добавлении, удалении или редактировании операций.
* Вести **откат состояния** через механизм снимков (Memento) и реализовать командную историю (Command + Undo/Redo).
* Вести проверку корректности данных через **валидацию** (Validator + Strategy).
* Демонстрировать функциональность через **консольный интерфейс** с удобными вводом и выводом данных.

Дополнительно реализованы:

* Измерение времени выполнения команд (TimedCommand).
* Сохранение и восстановление состояния репозиториев (SnapshotCommand + RepositoryCaretaker).
* Внутренняя структура с DI-контейнером для зависимостей репозиториев и валидатора.

## 2. Применение принципов SOLID и GRASP

### SOLID

1. **S – Single Responsibility Principle (Принцип единой ответственности)**

   * Каждый класс выполняет одну четко определенную задачу:

     * `BankAccount`, `Category`, `Operation` — представляют сущности доменной модели.
     * `Validator` — проверка корректности данных.
     * `OperationFacade`, `BankAccountFacade`, `CategoryFacade` — фасады для работы с репозиториями и управлением логикой.
     * `CommandManager` — управление выполнением команд (Undo/Redo).
     * `OperationNotifier` и `AccountBalanceObserver` — отдельная логика уведомления и обновления балансов.

2. **O – Open/Closed Principle (Принцип открытости/закрытости)**

   * Новые стратегии валидации можно добавлять через интерфейс `IValidationStrategy` без изменения фасадов или существующих классов.
   * Для добавления новых типов команд или наблюдателей достаточно реализовать соответствующий интерфейс (`ICommand`, `IOperationObserver`).

3. **L – Liskov Substitution Principle (Принцип подстановки Барбары Лисков)**

   * Все наследники интерфейсов (`IEntity`, `IRepository`, `ICommand`) могут использоваться вместо базовых типов без изменения логики работы приложения.

4. **I – Interface Segregation Principle (Принцип разделения интерфейсов)**

   * Разделены интерфейсы на узкоспециализированные:

     * `IRepository` — работа с данными.
     * `IValidator` — проверка данных.
     * `ICommand` — выполнение и отмена команд.
   * Это позволяет клиентам использовать только те методы, которые им нужны.

5. **D – Dependency Inversion Principle (Принцип инверсии зависимостей)**

   * Фасады и валидатор используют **интерфейсы репозиториев** и других зависимостей через конструктор.
   * DI-контейнер помогает автоматически управлять зависимостями, упрощает внедрение репозиториев и валидаторов в фасады и другие компоненты.
   * Это позволяет легко заменять реализации репозиториев, например, на InMemory или на файловую/БД реализацию, без изменения фасадов.

### GRASP

   **High Cohesion / Low Coupling (Высокая связность / низкая связность)**

   * Каждый класс сосредоточен на одной области ответственности:

     * Репозитории только хранят данные (`InMemoryRepository`).
     * Фасады управляют бизнес-логикой и взаимодействием репозиториев.
     * Observer и Notifier отделены от фасадов и не знают о деталях хранения данных.
   * Взаимодействие компонентов осуществляется через интерфейсы, что минимизирует зависимость модулей друг от друга.


## 3. Реализованные паттерны GoF

| Паттерн       | Где реализован                                                                                                      | Обоснование                                                                      |
| ------------- | ------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------- |
| **Observer**  | `IOperationObserver`, `OperationNotifier`, `AccountBalanceObserver`                                                 | Автоматическое обновление баланса счета при изменении операций                   |
| **Factory**   | `DomainFactory`                                                                                                     | Централизованное создание сущностей с автоматическим назначением ID и валидацией |
| **Builder**   | `OperationBuilder`                                                                                                  | Удобное построение объектов `Operation` с валидацией и опциональными полями      |
| **Strategy**  | `IValidationStrategy`, `BankAccountValidationStrategy`, `CategoryValidationStrategy`, `OperationValidationStrategy` | Позволяет менять логику валидации для разных сущностей без изменения фасадов     |
| **Facade**    | `BankAccountFacade`, `CategoryFacade`, `OperationFacade`                                                            | Упрощение работы с множеством репозиториев и связанной логики                    |
| **Command**   | `ICommand`, `AddOperationCommand`, `EditOperationCommand`, `DeleteOperationCommand`                                 | Реализация Execute/Undo операций                                                    |
| **Decorator** | `TimedCommand`                                                                                                      | Замер времени выполнения команд без изменения их логики                          |
| **Memento**   | `CommonInMemoryRepository::Snapshot`, `RepositoryCaretaker`, `SnapshotCommand`                                      | Возможность отката состояния репозиториев                                        |

> Использование этих паттернов обеспечивает расширяемость, модульность и повторное использование кода.

## 4. Инструкция по запуску

1. **Скачивание проекта**

   Склонируйте репозиторий с GitHub (или скачайте архив с проектом):

```bash
git clone <URL_репозитория>
cd <имя_папки_проекта>
```

2. **Создание сборки через CMake**
   
   Создайте отдельную директорию для сборки и соберите проект:

```bash
mkdir build
cd build
cmake ..
cmake --build .
```

3. **Запуск приложения**

   После сборки в директории `build` появится исполняемый файл KPO2.exe в папке Debug. Запустите его:

```bash
cd Debug
KPO2.exe
```
* Доступны команды Undo/Redo для отмены и повторного выполнения действий.
* Используется замер времени выполнения команд (`TimedCommand`) и сохранение/откат состояния репозиториев (`SnapshotCommand`).
